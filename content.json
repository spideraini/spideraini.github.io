{"meta":{"title":"Afennnnn","subtitle":null,"description":null,"author":"muyi","url":"https://spideraini.github.io"},"pages":[{"title":"404","date":"2017-10-29T17:22:24.000Z","updated":"2017-10-30T04:27:33.351Z","comments":true,"path":"404.html","permalink":"https://spideraini.github.io/404.html","excerpt":"","text":"你来到了荒原…"},{"title":"about","date":"2017-10-29T04:56:23.000Z","updated":"2017-10-29T04:58:12.051Z","comments":false,"path":"about/index.html","permalink":"https://spideraini.github.io/about/index.html","excerpt":"","text":"E-mail: cherishafen@foxmail.com"},{"title":"Categories","date":"2017-10-29T04:38:52.000Z","updated":"2017-10-30T04:46:49.518Z","comments":false,"path":"categories/index.html","permalink":"https://spideraini.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-29T04:37:57.000Z","updated":"2017-10-30T04:46:46.590Z","comments":false,"path":"tags/index.html","permalink":"https://spideraini.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2017百度之星资格赛 1003：度度熊与邪恶大魔王","slug":"2017百度之星资格赛-1003：度度熊与邪恶大魔王","date":"2017-10-28T15:43:25.000Z","updated":"2017-10-30T03:49:02.894Z","comments":true,"path":"2017/10/28/2017百度之星资格赛-1003：度度熊与邪恶大魔王/","link":"","permalink":"https://spideraini.github.io/2017/10/28/2017百度之星资格赛-1003：度度熊与邪恶大魔王/","excerpt":"Problem:度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。","text":"Problem:度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。如果度度熊使用第i个技能打在第j个怪兽上面的话，会使得第j个怪兽的生命值减少p[i]-b[j]，当然如果伤害小于防御，那么攻击就不会奏效。怪兽的生命值降为0或以下，那么怪兽就会被消灭。每个技能都可以使用无限次。请问度度熊最少携带多少晶石，就可以消灭所有的怪兽。Input:本题包含若干组测试数据。第一行两个整数n，m,表示有n个怪兽，m种技能。接下来n行，每行两个整数，a[i],b[i]，分别表示怪兽的生命值和防御力。再接下来m行，每行两个整数k[i]和p[i]，分别表示技能的消耗晶石数目和技能的伤害值。 数据范围:1&lt;=n&lt;=1000001&lt;=m&lt;=10001&lt;=a[i]&lt;=10000&lt;=b[i]&lt;=100&lt;=k[i]&lt;=1000000&lt;=p[i]&lt;=1000 Output:对于每组测试数据，输出最小的晶石消耗数量，如果不能击败所有的怪兽，输出-1-Sample Input1 23 57 106 81 23 510 78 6Sample Out618 问题如上。关于这道题，网上大多采用的是完全背包求解，这里我用了另外一种方法——穷举。。。对于每个怪兽来说，所有的技能只有三种情况：1.技能攻击力 &lt;= 怪兽防御力，此类技能无法对怪兽造成伤害，因此可以直接跳过；2.攻击力 &gt;= 防御力 + 怪兽生命值，此类技能可以对怪兽一击秒杀，因此只需在此类技能中选择耗费晶石最少的技能即可；3.攻击力 &gt; 防御力 &amp;&amp; 攻击力 &lt; 防御力 + 生命值，此类技能无法对怪兽一击秒杀，但可以造成伤害，因此需要多个技能组合起来杀死怪兽。这道题的难点在于第三种情况的技能该如何选择。首先，虽然每个技能可以无限次使用，但对于每个符合第三种情况的技能，当 使用次数 &gt; 怪兽的生命值/（攻击力 - 防御力）+ 1 时，再使用此技能没有意义，因为之前的技能累加起来的伤害值已经足够把怪兽打死了。所以可以建立一个新数组，数组中储存符合第三种情况的技能，并且每个技能重复 生命值/（攻击力 - 防御力）+ 1 次，该数组的总长度也可以计算出来，这里先记为 length 。因此对于新数组中的每一项来说，就只有选和不选两种情况，如果用0代表不选，用1代表选，那么用 1～pow(2,length) - 1 这之间数字的二进制形式就可以表示出来所有情况。对于每一种情况，即每个数字的二进制形式，只需找出含1的位置，因为二进制形式的每个位置都与此前建立的新数组对应，因此就可以得到当前情况的技能选择，从而可以求出这种情况造成的伤害值和耗费的晶石数量。若当前伤害值不超过怪兽的生命值，则可以跳过这次情况；若当前耗费晶石数量大于一开始的第二种情况（攻击力 &gt;= 防御力 + 生命值），也可以跳过这次情况。所以只需在剩下的情况中选择耗费晶石数量最少的情况即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define min(a, b) (a) &lt; (b) ? (a) : (b)class Solution&#123;public: int dudubear(vector&lt;int&gt; life, vector&lt;int&gt; defense, vector&lt;int&gt; star, vector&lt;int&gt; attack, int n, int m) &#123; int rightMinValue = 100000, leftMinValue = 100000, sum = 0; vector&lt;int&gt; selectValue; vector&lt;int&gt; newselectValue; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (attack[j] &gt;= life[i] + defense[i]) &#123; rightMinValue = min(star[j], rightMinValue); continue; &#125; if ((attack[j] &gt; defense[i]) &amp;&amp; (attack[j] &lt; defense[i] + life[i])) &#123; selectValue.push_back(j); continue; &#125; if (j == m - 1) &#123; return -1; &#125; &#125; //因为技能可重复使用，但单个技能重复使用累加起来的伤害（攻击-防御）超过怪兽的生命值时无意义 //所以每个技能的使用次数不能超过(life[i] / (attack[selectValue[j]] - defense[i]))+1 //建立新数组，储存单个技能使用最大次数的数组 int count = 0; for (int j = 0; j &lt; selectValue.size(); ++j) &#123; int items = (life[i] / (attack[selectValue[j]] - defense[i])) + 1; for (int k = 0; k &lt; items; ++k) &#123; newselectValue.push_back(selectValue[j]); ++count; &#125; &#125; int flag = 4; int bitcount = 2; for (int j = 3; j &lt; (int)pow(2, count); ++j) &#123; if (j == flag) &#123; flag = flag &lt;&lt; 1; ++bitcount; continue; &#125; //计算当前情况所耗费晶石数量 int sumDamage = 0, sumStar = 0; for (int k = 1; k &lt; bitcount + 1; ++k) &#123; if ((j &gt;&gt; (k - 1) &amp; 1) == 1) &#123; sumDamage += attack[newselectValue[count - k]] - defense[i]; sumStar += star[newselectValue[count - k]]; &#125; &#125; if (sumDamage &lt; life[i]) continue; if (sumStar &gt; rightMinValue) continue; leftMinValue = min(sumStar, leftMinValue); &#125; leftMinValue == 100000 ? sum += rightMinValue : sum += leftMinValue; leftMinValue = 100000; rightMinValue = 100000; selectValue.clear(); newselectValue.clear(); &#125; return sum; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://spideraini.github.io/categories/刷题/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://spideraini.github.io/tags/C/"}]},{"title":"leetcode42. Trapping Rain Water","slug":"leetcode42-Trapping-Rain-Water","date":"2017-10-28T05:43:25.000Z","updated":"2017-10-30T05:07:44.002Z","comments":true,"path":"2017/10/28/leetcode42-Trapping-Rain-Water/","link":"","permalink":"https://spideraini.github.io/2017/10/28/leetcode42-Trapping-Rain-Water/","excerpt":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.","text":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image!题目如上，求给定的数组所能容纳的“雨水数量“。 首先从图可以看出，能容纳雨水的部分都有一个特点，那就是两边高中间低，只有这样才可以盛下”雨水“，因此只要在整个数组当中，找出符合此条件的部分，就完成了第一步。 而具体的实现就是在当前位置之后，找出比当前元素大或相等的下一个元素，这两个元素就可以构成两条边，而这两条边构成的容器所能容纳的”雨水数量“=min(left,right)*(left-right-1)-(left~right中间部分的元素之和)。 在整个数组范围内找出这样的部分，并求每个部分所能容纳的”雨水数量“，最后将得到的”雨水数量“相加即可。 12345678910111213141516171819202122232425262728class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int sum=0,flag; for(int i=0;i&lt;height.size();++i)&#123; for (int j=i+1;j&lt;height.size();++j) &#123; if(height[j]&gt;=height[i])&#123; sum+=height[i]*(j-i-1); for(int m=i+1;m&lt;j;++m)&#123; sum-=height[m]; &#125; i=j-1; break; &#125; if(j==height.size()-1)&#123; vector&lt;int&gt;::iterator maxelem = max_element(height.begin()+i+1, height.end()); flag = std::distance(height.begin(), maxelem); sum+=height[flag]*(flag-i-1); for(int m=i+1;m&lt;flag;++m)&#123; sum-=height[m]; &#125; i=flag-1; &#125; &#125; &#125; return sum; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://spideraini.github.io/categories/刷题/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://spideraini.github.io/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://spideraini.github.io/tags/LeetCode/"}]},{"title":"leetcode68. Text JustificationWater","slug":"leetcode68-Text-Justification","date":"2017-10-27T19:43:25.000Z","updated":"2017-10-30T05:07:54.152Z","comments":true,"path":"2017/10/28/leetcode68-Text-Justification/","link":"","permalink":"https://spideraini.github.io/2017/10/28/leetcode68-Text-Justification/","excerpt":"Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.","text":"Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.For the last line of text, it should be left justified and no extra space is inserted between words. For example,words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]L: 16. Return the formatted lines as: [ &quot;This is an&quot;, &quot;example of text&quot;, &quot;justification. &quot; ] 问题如上，此题要求把给定的一组单词合理划分成几行，使每一行都有尽可能多的单词，并且使单词与单词之间的空字符合理分布，且每行字符长度不得超过给定长度。 这道题的总体思路很简单，然而具体实现却又很复杂。 先说一下大体思路。首先是每一行的单词选择，每一行都由一个或多个单词和空字符组成，且单词必须按原始顺序排列，所以只要不断累加单词和空字符的长度，当累加长度大于给定长度时，则说明最后加入的这个单词不能放入这一行，因此这一行就由最后一个单词前面的单词所组成，同样下一行再通过这样的方式去判断，就可以得出每一行应选择的单词。 因此判断每行所选择的单词就涉及到了两个条件，一是单词的长度，单词的长度可以通过size函数获取；二是每行空字符的数量，根据题意，单词与单词之间至少有一个空字符，因此判断 当前累加单词长度+单词数量-1&gt;给定长度 即可，然后在这个条件判断内部获取前面的单词和进行空字符分配。 然而，通过上面的方式并不能得到最后一行的单词，最后一行的单词累加长度+必须的空字符数量&lt;=给定长度，所以上面那种方法并不适用于最后一行的单词选择。这里可以通过判断 给定的这一组单词剩余的单词长度+必须的空字符数量&lt;=给定长度 来选择最后一行的单词，这种方式肯定会增加程序的复杂程度。 另一种方式很简单，只需要给给定数组push进一个和给定长度相当的任意字符串即可，这样在选择最后一行的单词时，就可以符合上面的条件。1words.push_back(string(maxWidth, &apos;a&apos;)); 在确定好当前行应选择的单词后，就应该将单词push进新数组，同时分配空字符。 空字符的分配相比较每行单词的选择更为复杂，首先需要知道每行空字符的数量，因为每行字符长度不得超过给定长度，因此 当前行空字符数量=给定长度-当前行单词累加长度，然后需要知道每行应分配几处空字符，即空字符应分配的区域有几处，通过例子可以看出，当单词数量为1时，有一处空字符，且空字符在最右边，当单词数量大于1时，空字符数量均匀分布，当不能完全均匀分布时，左边的空字符数量要多于右边，因此：12k-- &gt; 0 ? 当前位置应分配的空字符数量 = 当前行空字符数量 / 空字符应分配的区域数量 + 1 : 当前位置应分配的空字符数量 = 当前行空字符数量 / 空字符应分配的区域数量;str += string(当前位置应分配的空字符数量, &apos; &apos;); 这里的 k=当前行空字符数量%空字符应分配的区域数量。 上面的第一行代码就可以实现空字符的均匀分配，然后通过第二行代码将与该行当前区域应分配的空字符数量相当的空字符写入str中。 需要注意的是，最后一行并不是按照这个规则来进行空字符分配的。因此，最后一行的空字符需要另外分配。 下面是具体实现代码 123456789101112131415161718192021222324252627282930313233343536class Solution&#123; public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int maxWidth)&#123; vector&lt;string&gt; sum; //用于返回处理完后的数组 int wordsWidth = 0; //每行单词字符长度 int nullCharTotalWidth, nullCharArea, nullCharWidth; //每行空字符总数量，每行空字符区间，每个空字符区间中空字符的数量 int start = 0,k,flag=0; //每次起始点，空字符总数%空字符区间，储存最后一行已用空字符 string str = \"\"; //每行累加的字符串 words.push_back(string(maxWidth, 'a')); for (int i = 0; i &lt; words.size(); ++i)&#123; wordsWidth += words[i].size(); nullCharArea = i - start; if (wordsWidth + nullCharArea &gt; maxWidth)&#123; nullCharTotalWidth = maxWidth - wordsWidth + words[i].size(); --nullCharArea == 0 ? nullCharArea = 1 : nullCharArea = nullCharArea; k = nullCharTotalWidth % nullCharArea; for (int j = start; j &lt; i; ++j)&#123; str += words[j]; if (i == words.size() - 1)&#123; j &lt; i - 1 ? str += \" \": str += string(nullCharTotalWidth - flag, ' '); ++flag; continue; &#125; if ((j == i - 1) &amp;&amp; (start != i - 1)) break; k-- &gt; 0 ? nullCharWidth = nullCharTotalWidth / nullCharArea + 1 : nullCharWidth = nullCharTotalWidth / nullCharArea; str += string(nullCharWidth, ' '); &#125; sum.push_back(str); str = \"\"; wordsWidth = 0; start = i--; &#125; &#125; return sum; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://spideraini.github.io/categories/刷题/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://spideraini.github.io/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://spideraini.github.io/tags/LeetCode/"}]}]}