{"meta":{"title":"Afennnnn","subtitle":null,"description":null,"author":"E-mail","url":"https://spideraini.github.io"},"pages":[{"title":"","date":"2017-10-28T22:17:45.418Z","updated":"2017-10-28T22:17:45.418Z","comments":true,"path":"404.html","permalink":"https://spideraini.github.io/404.html","excerpt":"","text":"404…"}],"posts":[{"title":"2017百度之星资格赛 1003：度度熊与邪恶大魔王","slug":"2017百度之星资格赛-1003：度度熊与邪恶大魔王","date":"2017-10-28T15:43:25.000Z","updated":"2017-10-29T00:24:47.950Z","comments":true,"path":"2017/10/28/2017百度之星资格赛-1003：度度熊与邪恶大魔王/","link":"","permalink":"https://spideraini.github.io/2017/10/28/2017百度之星资格赛-1003：度度熊与邪恶大魔王/","excerpt":"Problem:度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。","text":"Problem:度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。如果度度熊使用第i个技能打在第j个怪兽上面的话，会使得第j个怪兽的生命值减少p[i]-b[j]，当然如果伤害小于防御，那么攻击就不会奏效。怪兽的生命值降为0或以下，那么怪兽就会被消灭。每个技能都可以使用无限次。请问度度熊最少携带多少晶石，就可以消灭所有的怪兽。Input:本题包含若干组测试数据。第一行两个整数n，m,表示有n个怪兽，m种技能。接下来n行，每行两个整数，a[i],b[i]，分别表示怪兽的生命值和防御力。再接下来m行，每行两个整数k[i]和p[i]，分别表示技能的消耗晶石数目和技能的伤害值。 数据范围:1&lt;=n&lt;=1000001&lt;=m&lt;=10001&lt;=a[i]&lt;=10000&lt;=b[i]&lt;=100&lt;=k[i]&lt;=1000000&lt;=p[i]&lt;=1000 Output:对于每组测试数据，输出最小的晶石消耗数量，如果不能击败所有的怪兽，输出-1-Sample Input1 23 57 106 81 23 510 78 6Sample Out618 问题如上。关于这道题，网上大多采用的是完全背包求解，这里我用了另外一种方法——穷举。。。对于每个怪兽来说，所有的技能只有三种情况：1.技能攻击力 &lt;= 怪兽防御力，此类技能无法对怪兽造成伤害，因此可以直接跳过；2.攻击力 &gt;= 防御力 + 怪兽生命值，此类技能可以对怪兽一击秒杀，因此只需在此类技能中选择耗费晶石最少的技能即可；3.攻击力 &gt; 防御力 &amp;&amp; 攻击力 &lt; 防御力 + 生命值，此类技能无法对怪兽一击秒杀，但可以造成伤害，因此需要多个技能组合起来杀死怪兽。这道题的难点在于第三种情况的技能该如何选择。首先，虽然每个技能可以无限次使用，但对于每个符合第三种情况的技能，当 使用次数 &gt; 怪兽的生命值/（攻击力 - 防御力）+ 1 时，再使用此技能没有意义，因为之前的技能累加起来的伤害值已经足够把怪兽打死了。所以可以建立一个新数组，数组中储存符合第三种情况的技能，并且每个技能重复 生命值/（攻击力 - 防御力）+ 1 次，该数组的总长度也可以计算出来，这里先记为 length 。因此对于新数组中的每一项来说，就只有选和不选两种情况，如果用0代表不选，用1代表选，那么用 1～pow(2,length) - 1 这之间数字的二进制形式就可以表示出来所有情况。对于每一种情况，即每个数字的二进制形式，只需找出含1的位置，因为二进制形式的每个位置都与此前建立的新数组对应，因此就可以得到当前情况的技能选择，从而可以求出这种情况造成的伤害值和耗费的晶石数量。若当前伤害值不超过怪兽的生命值，则可以跳过这次情况；若当前耗费晶石数量大于一开始的第二种情况（攻击力 &gt;= 防御力 + 生命值），也可以跳过这次情况。所以只需在剩下的情况中选择耗费晶石数量最少的情况即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define min(a, b) (a) &lt; (b) ? (a) : (b)class Solution&#123;public: int dudubear(vector&lt;int&gt; life, vector&lt;int&gt; defense, vector&lt;int&gt; star, vector&lt;int&gt; attack, int n, int m) &#123; int rightMinValue = 100000, leftMinValue = 100000, sum = 0; vector&lt;int&gt; selectValue; vector&lt;int&gt; newselectValue; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (attack[j] &gt;= life[i] + defense[i]) &#123; rightMinValue = min(star[j], rightMinValue); continue; &#125; if ((attack[j] &gt; defense[i]) &amp;&amp; (attack[j] &lt; defense[i] + life[i])) &#123; selectValue.push_back(j); continue; &#125; if (j == m - 1) &#123; return -1; &#125; &#125; //因为技能可重复使用，但单个技能重复使用累加起来的伤害（攻击-防御）超过怪兽的生命值时无意义 //所以每个技能的使用次数不能超过(life[i] / (attack[selectValue[j]] - defense[i]))+1 //建立新数组，储存单个技能使用最大次数的数组 int count = 0; for (int j = 0; j &lt; selectValue.size(); ++j) &#123; int items = (life[i] / (attack[selectValue[j]] - defense[i])) + 1; for (int k = 0; k &lt; items; ++k) &#123; newselectValue.push_back(selectValue[j]); ++count; &#125; &#125; int flag = 4; int bitcount = 2; for (int j = 3; j &lt; (int)pow(2, count); ++j) &#123; if (j == flag) &#123; flag = flag &lt;&lt; 1; ++bitcount; continue; &#125; //计算当前情况所耗费晶石数量 int sumDamage = 0, sumStar = 0; for (int k = 1; k &lt; bitcount + 1; ++k) &#123; if ((j &gt;&gt; (k - 1) &amp; 1) == 1) &#123; sumDamage += attack[newselectValue[count - k]] - defense[i]; sumStar += star[newselectValue[count - k]]; &#125; &#125; if (sumDamage &lt; life[i]) continue; if (sumStar &gt; rightMinValue) continue; leftMinValue = min(sumStar, leftMinValue); &#125; leftMinValue == 100000 ? sum += rightMinValue : sum += leftMinValue; leftMinValue = 100000; rightMinValue = 100000; selectValue.clear(); newselectValue.clear(); &#125; return sum; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://spideraini.github.io/categories/刷题/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://spideraini.github.io/tags/C/"}]},{"title":"leetcode42. Trapping Rain Water","slug":"leetcode42-Trapping-Rain-Water","date":"2017-10-28T05:43:25.000Z","updated":"2017-10-29T00:24:12.590Z","comments":true,"path":"2017/10/28/leetcode42-Trapping-Rain-Water/","link":"","permalink":"https://spideraini.github.io/2017/10/28/leetcode42-Trapping-Rain-Water/","excerpt":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.","text":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image!题目如上，求给定的数组所能容纳的“雨水数量“。 首先从图可以看出，能容纳雨水的部分都有一个特点，那就是两边高中间低，只有这样才可以盛下”雨水“，因此只要在整个数组当中，找出符合此条件的部分，就完成了第一步。 而具体的实现就是在当前位置之后，找出比当前元素大或相等的下一个元素，这两个元素就可以构成两条边，而这两条边构成的容器所能容纳的”雨水数量“=min(left,right)*(left-right-1)-(left~right中间部分的元素之和)。 在整个数组范围内找出这样的部分，并求每个部分所能容纳的”雨水数量“，最后将得到的”雨水数量“相加即可。 12345678910111213141516171819202122232425262728class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int sum=0,flag; for(int i=0;i&lt;height.size();++i)&#123; for (int j=i+1;j&lt;height.size();++j) &#123; if(height[j]&gt;=height[i])&#123; sum+=height[i]*(j-i-1); for(int m=i+1;m&lt;j;++m)&#123; sum-=height[m]; &#125; i=j-1; break; &#125; if(j==height.size()-1)&#123; vector&lt;int&gt;::iterator maxelem = max_element(height.begin()+i+1, height.end()); flag = std::distance(height.begin(), maxelem); sum+=height[flag]*(flag-i-1); for(int m=i+1;m&lt;flag;++m)&#123; sum-=height[m]; &#125; i=flag-1; &#125; &#125; &#125; return sum; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://spideraini.github.io/categories/刷题/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://spideraini.github.io/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://spideraini.github.io/tags/leetcode/"}]}]}